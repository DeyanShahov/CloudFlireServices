Описание на Работния Процес на Сървъра

Този документ описва основните работни потоци и процеси, които се случват в Node.js сървърното приложение. Сървърът управлява задачи за генериране на изображения, взаимодействие с Cloudflare R2 за съхранение на файлове, RabbitMQ за опашки от съобщения, Redis за кеширане и управление на състояния, и PostgreSQL за съхранение на метаданни (въпреки че основният фокус на новата логика е върху Redis).

1. Инициализация на Сървъра
-----------------------------
При стартиране на приложението се извършват следните стъпки:
1.1. **Проверка на Зависимости (`ensureDependencies`)**:
    - Проверява дали всички необходими npm пакети, дефинирани в `package.json`, са инсталирани.
    - Ако липсват зависимости, прави опит да ги инсталира автоматично чрез `npm install`.
    - При успешна инсталация, скриптът изисква рестартиране.
1.2. **Зареждане на Конфигурация**:
    - Променливите на средата се зареждат от `.env` файла (напр. ключове за достъп, URL адреси на услуги).
1.3. **Свързване с Външни Услуги**:
    - **RabbitMQ (`connectRabbitMQ`)**: Установява връзка с RabbitMQ сървъра. Конфигурира exchange, опашка (queue) и връзка (binding) между тях. Има логика за автоматично повторно свързване при загуба на връзката.
    - **Redis (`connectRedis`)**: Установява връзка с Redis сървъра (Upstash). Има логика за обработка на грешки и събития при свързване.
    - **PostgreSQL (`pgPool`)**: Създава се пул от връзки към PostgreSQL базата данни.
    - **Cloudflare R2 (S3 Client)**: Конфигурира се S3 клиент за взаимодействие с Cloudflare R2, използвайки предоставените endpoint и идентификационни данни.
1.4. **Стартиране на Express Приложение**:
    - Създава се Express приложение.
    - Прилагат се middleware-и за парсване на JSON и URL-encoded заявки.
    - Дефинират се ендпойнтите.
1.5. **Стартиране на Диспечерския Механизъм**:
    - След успешно свързване с Redis, се стартира периодична задача (`runDispatcherCycle`), която проверява за готови задачи.


2. Създаване на Нова Задача (чрез Redis - `/jobsRedis`)
----------------------------------------------------
Това е основният ендпойнт за подаване на нови задачи за генериране на изображения.
2.1. **Получаване на Заявка**: Клиент изпраща POST заявка към `/jobsRedis` с JSON тяло, съдържащо `userId` и други параметри на задачата (prompt, стилове и т.н.).
2.2. **Валидация**: Проверява се дали `userId` е предоставен и дали Redis клиентът е наличен и готов.
2.3. **Генериране на ID и Данни**:
    - Генерира се уникален `jobId` (UUID).
    - Задава се начален `status` на 'pending'.
    - Записва се времето на създаване (`created_at`).
    - Подготвя се обект (`jobDataToStore`) с всички данни за задачата, като масивите и обектите се преобразуват в JSON стрингове за съхранение в Redis Hash.
2.4. **Запис в Redis (Атомарна Операция)**:
    - Използва се Redis `MULTI` транзакция за атомарност.
    - Данните за задачата (`jobDataToStore`) се записват в Redis Hash, където ключът е `jobId`.
    - `jobId` се добавя към Redis Set с име `jobs:status:pending`. Този Set съдържа ID-тата на всички задачи, които чакат обработка.
2.5. **Изпращане към RabbitMQ**:
    - Ако връзката с RabbitMQ е активна, се формира съобщение, съдържащо `job_id` и основни входни параметри.
    - Съобщението се публикува в конфигурирания RabbitMQ exchange с routing key, което го насочва към съответната опашка. Съобщението е маркирано като `persistent`.
    - Това съобщение се очаква да бъде консумирано от външни worker услуги, които реално ще извършат генерирането на изображението.
2.6. **Отговор към Клиента**:
    - Връща се HTTP 201 (Created) отговор с `jobId` на новосъздадената задача.


3. Диспечерски Механизъм (`runDispatcherCycle`)
----------------------------------------------
Тази функция се изпълнява периодично (напр. на всеки 5 секунди) и управлява готовите задачи.
3.1. **Проверка за Готови Задачи**:
    - Извлича всички `jobId`-та от Redis Set `jobs:status:ready`. Този Set се очаква да бъде попълван от worker услугите, след като успешно генерират изображение и го качат в R2.
3.2. **Обработка на Всяка Готова Задача**:
    - За всеки `jobId` от `jobs:status:ready`:
        - Проверява дали задачата вече не е в локалния кеш на диспечера (`readyJobsForClientCache`). Ако е, само се уверява, че е в правилния Redis Set (`JOB_STATUS_DISPATCHER_CACHE_PROCESSING`).
        - Извлича пълните данни за задачата от нейния Redis Hash.
        - **Ако задачата е валидна и готова**:
            - Проверява дали `status` в Hash-а е 'ready' и дали има `output_r2_key` (ключ към генерираното изображение в R2).
            - **Атомарно преместване**: `jobId` се премества от `jobs:status:ready` Set в `jobs:status:dispatcher_cache_processing` Set. Това гарантира, че друга инстанция на диспечера (ако има такива) или същата инстанция при следващ цикъл няма да обработи отново същата задача.
            - **Локално кеширане**: Информацията за задачата (включително `r2Key`, `userId`, време на кеширане и време на изтичане на кеша - TTL) се добавя в локалната `Map` структура `readyJobsForClientCache`.
        - **Обработка на неконсистентност**: Ако задача е в `jobs:status:ready`, но данните в Hash-а не отговарят (напр. различен статус или липсващ `output_r2_key`), тя се премахва от `jobs:status:ready` Set, за да се избегнат проблеми.
3.3. **Почистване на Локалния Кеш (TTL)**:
    - Итерира през задачите в `readyJobsForClientCache`.
    - Ако времето на живот (TTL) на дадена задача в кеша е изтекло (т.е. клиентът не я е потърсил в рамките на зададения период):
        - Задачата се премахва от `readyJobsForClientCache`.
        - Прави се опит `jobId` да бъде преместен обратно от `jobs:status:dispatcher_cache_processing` Set в `jobs:status:ready` Set. Това позволява на задачата да бъде "видяна" отново от диспечера при следващ цикъл или да бъде изтеглена директно от клиента, ако той направи заявка за нея.
        - **Ако преместването е неуспешно**:
            - Проверява се дали задачата все още съществува в Redis.
            - Ако не съществува, това означава, че вероятно е била обработена и изтрита от ендпойнта `/jobResult`. Записът се премахва само от локалния кеш.
            - Ако все още съществува, но преместването е неуспешно по друга причина, записът се премахва от локалния кеш и се логва съобщение.
        - Успешното преместване обратно в `jobs:status:ready` позволява на задачата да бъде "видяна" отново от диспечера при следващ цикъл или да бъде изтеглена директно от клиента.


4. Извличане на Резултат от Задача (`/jobResult?jobId=<ID>`)
-------------------------------------------------------
Клиентите използват този ендпойнт, за да проверяват периодично (polling) дали тяхната задача е готова и да изтеглят резултата.
След успешно получаване на резултата от клиента, всички данни свързани със задачата (в Redis и R2) се изтриват.
4.1. **Получаване на Заявка**: Клиент изпраща GET заявка към `/jobResult` с query параметър `jobId`.
4.2. **Извличане на Данни от Redis**:
    - Сървърът извлича всички данни (Hash) за задачата от Redis чрез `HGETALL jobId`.
4.3. **Обработка на Статуса на Задачата**:
    - **Ако задачата не е намерена в Redis**:
        - Ако `jobId` е бил в локалния кеш на диспечера (`readyJobsForClientCache`), той се премахва оттам.
        - Връща се HTTP 404 (Not Found).
    - **Ако задачата е със статус 'ready' и има `output_r2_key`**:
        - Изображението се извлича от Cloudflare R2.
        - Изображението се кодира в Base64 и се изпраща в JSON отговор, съдържащ `status: "completed"`, `image_data_base64` и `image_type`.
        - **Пълно Почистване**: След успешно изпращане на отговора, се извиква функция `performFullCleanup`. Тази функция:
            - Изтрива изображението от Cloudflare R2.
            - Изтрива основния Hash на задачата от Redis.
            - Премахва `jobId` от всички релевантни Redis status Sets (`jobs:status:pending`, `jobs:status:ready`, `jobs:status:dispatcher_cache_processing`).
            - Премахва `jobId` от локалния кеш на диспечера (`readyJobsForClientCache`), ако е там.
        - **При грешка 'NoSuchKey' от R2** (файлът липсва, въпреки че статусът е 'ready'):
            - Връща се HTTP 404.
            - Извиква се `performFullCleanup` (без R2 ключ), за да се почистят данните от Redis.
    - **Ако задачата е със статус 'pending' или 'processing'**: Връща се HTTP 202 (Accepted) със съобщение, че задачата все още се обработва.
    - **Ако задачата е със статус 'failed'**:
        - Връща се HTTP 200 с JSON отговор, съдържащ `status: "failed"` и съобщение за грешка.
        - **Пълно Почистване**: Извиква се `performFullCleanup` (без R2 ключ), за да се изтрият данните за задачата от Redis и локалния кеш на диспечера.
    - **Ако задачата е със статус 'ready', но липсва `output_r2_key` (неконсистентно състояние)**:
        - Връща се HTTP 500.
        - **Пълно Почистване**: Извиква се `performFullCleanup` (без R2 ключ), за да се изтрият данните за задачата от Redis и локалния кеш на диспечера.
    - **Други или неизвестни статуси**:
        - Връща се HTTP 200 с текущия статус на задачата. Данните не се трият на този етап.


5. Предположения за Външни Worker Услуги
-----------------------------------------
Системата разчита на външни worker услуги (не са част от този код), които:
5.1. **Консумират съобщения** от RabbitMQ опашката.
5.2. **Обработват задачите**: Извършват реалното генериране на изображения.
5.3. **Актуализират статуса в Redis**:
    - При започване на обработка, могат да променят статуса в Hash-а на 'processing' и да преместят `jobId` от `jobs:status:pending` в `jobs:status:processing` Set (този Set не се управлява активно от текущия сървър, но е логично да съществува).
    - След успешно генериране, качват изображението в Cloudflare R2.
    - Записват `output_r2_key` (ключа към файла в R2) и `output_image_url` (ако е приложимо) в Redis Hash-а на задачата.
    - Променят статуса в Hash-а на 'ready'.
    - Преместват `jobId` от `jobs:status:processing` (или `jobs:status:pending`) в `jobs:status:ready` Set.
    - При грешка, променят статуса на 'failed', записват съобщение за грешка в Hash-а и преместват `jobId` в `jobs:status:failed` Set.

6. Други Ендпойнти
-------------------
6.1. **`/upload` (POST)**:
    - Позволява качване на един или няколко файла (изпратени като `multipart/form-data` с поле `imageFiles` и `userId`).
    - Файловете се записват в Cloudflare R2 под ключ с формат `userId/originalFilename`.
    - Връща информация за качените файлове.
6.2. **`/images/:userId` (GET)**:
    - Извлича списък с всички изображения за даден `userId` от R2.
    - Изображенията се връщат като Base64 кодирани низове в JSON масив.
    - **След успешно изпращане на отговора, всички извлечени изображения за този потребител се изтриват от R2.**
6.3. **`/image/raw/:key(*)` (GET)**:
    - Извлича суровите данни на единично изображение от R2 по неговия пълен ключ.
    - Полезен за директна визуализация. Не изтрива файла.
6.4. **`/jobs` (POST)**:
    - Подобен на `/jobsRedis`, но записва информацията за задачата в PostgreSQL база данни (`jobs2` таблица).
    - Също изпраща съобщение към RabbitMQ. Този ендпойнт изглежда е по-стара версия или алтернативен начин за управление на задачи, като основният фокус на новата логика е върху Redis.

7. Грациозно Спиране (`gracefulShutdown`)
----------------------------------------
При получаване на сигнал за спиране (SIGINT, SIGTERM):
7.1. Спира се диспечерският интервал (`dispatcherIntervalId`).
7.2. Затварят се връзките към RabbitMQ, Redis и PostgreSQL pool-а, за да се освободят ресурси и да се предотвратят грешки.
7.3. Процесът на приложението приключва.

Този работен процес осигурява асинхронна обработка на задачи, управление на състоянията им чрез Redis и механизъм за клиентите да получават резултатите, когато са готови, като същевременно се управлява натоварването и ресурсите на сървъра.