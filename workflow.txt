Описание на Работния Процес на Системата (Node.js СървъР + Python Worker)

Този документ описва основните работни потоци и процеси, които се случват в цялостната система, включваща Node.js сървърното приложение и външни Python worker-и. Системата управлява задачи за генериране на изображения, взаимодействие с Cloudflare R2 за съхранение на файлове, RabbitMQ за опашки от съобщения, Redis за управление на състояния, и PostgreSQL за съхранение на метаданни (въпреки че основният фокус на новата логика е върху Redis).

1. Инициализация на Сървъра
-----------------------------
При стартиране на приложението се извършват следните стъпки:
1.1. **Проверка на Зависимости (`ensureDependencies`)**: Проверява дали всички необходими npm пакети, дефинирани в `package.json`, са инсталирани. Ако липсват, прави опит да ги инсталира автоматично.
1.2. **Зареждане на Конфигурация**:
    - Променливите на средата се зареждат от `.env` файла (напр. ключове за достъп, URL адреси на услуги).
    - Инициализира се системата за логване (`logger.js` с `winston`), която записва логове в конзолата и във файлове (`logs/combined.log`, `logs/error.log`).
1.3. **Свързване с Външни Услуги**:
    - **RabbitMQ (`connectRabbitMQ`)**: Установява връзка с RabbitMQ сървъра. Конфигурира exchanges, опашки (queues) и връзки (bindings) за двата типа задачи (`TextQueue` и `OutfitQueue`). Има логика за автоматично повторно свързване.
    - **Redis (`connectRedis`)**: Установява връзка с Redis сървъра (Upstash). Има логика за обработка на грешки и събития при свързване.
    - **PostgreSQL (`pgPool`)**: Създава се пул от връзки към PostgreSQL базата данни.
    - **Cloudflare R2 (S3 Client)**: Конфигурира се S3 клиент за взаимодействие с Cloudflare R2, използвайки предоставените endpoint и идентификационни данни.
1.4. **Стартиране на Express Приложение**:
    - Създава се Express приложение.
    - Прилагат се middleware-и за парсване на JSON и URL-encoded заявки.
    - Дефинират се ендпойнтите.
1.5. **Стартиране на Диспечерски Механизъм**:
    - След успешно свързване с Redis, се стартира периодична задача (`runDispatcherCycle`), която проверява за готови задачи.
    - Диспечерът стартира в **"работещ" (active) режим** с по-чести проверки (конфигурируемо, напр. на всеки 5 секунди).
    - Може да премине в **"заспал" (idle) режим** с по-редки проверки (конфигурируемо, напр. на всяка минута), ако няма активност за определен период (конфигурируемо, напр. 30 секунди).
    - Активност, която "събужда" диспечера или удължава "работещия" му режим, включва създаване на нова задача или заявка за резултат от задача.

2. Създаване на Нова Задача (чрез Redis - `/jobsRedis`)
----------------------------------------------------
Това е основният ендпойнт за подаване на нови задачи за генериране на изображения.
2.1. **Получаване на Заявка**: Клиент изпраща POST заявка към `/jobsRedis` с JSON тяло, съдържащо `userId` и други параметри на задачата (prompt, стилове и т.н.).
2.2. **Валидация**: Проверява се дали `userId` е предоставен и дали Redis клиентът е наличен и готов.
2.3. **Генериране на ID и Данни**:
    - Генерира се уникален `jobId` (UUID).
    - Задава се начален `status` на 'pending'.
    - Записва се времето на създаване (`created_at`).
    - Подготвя се обект (`jobDataToStore`) с всички данни за задачата, като масивите и обектите се преобразуват в JSON стрингове за съхранение в Redis Hash.
2.4. **Запис в Redis (Атомарна Операция)**:
    - Използва се Redis `MULTI` транзакция за атомарност.
    - Данните за задачата (`jobDataToStore`) се записват в Redis Hash, където ключът е `jobId`.
    - `jobId` се добавя към Redis Set с име `jobs:status:pending`. Този Set съдържа ID-тата на всички задачи, които чакат обработка.
2.5. **Изпращане към RabbitMQ**:
    - Ако връзката с RabbitMQ е активна, се формира съобщение, съдържащо `job_id` и основни входни параметри.
    - Съобщението се публикува в конфигурирания RabbitMQ exchange с routing key, което го насочва към съответната опашка. Съобщението е маркирано като `persistent`.
    - Това съобщение се очаква да бъде консумирано от външни worker услуги, които реално ще извършат генерирането на изображението.
2.6. **Отговор към Клиента**:
    - Връща се HTTP 201 (Created) отговор, съдържащ `jobId` на новосъздадената задача.
2.7. **Активиране на Диспечера**:
    - Създаването на нова задача превключва диспечерския механизъм в "работещ" режим (или удължава текущия му "работещ" период), за да може новата задача да бъде обработена по-бързо, когато стане готова.

3. Създаване на Нова Задача (Смяна на Облекло - `/jobChangeOutfit`)
-----------------------------------------------------------------
Този ендпойнт управлява задачи, които изискват обработка на входни изображения.
3.1. **Получаване на Заявка**: Клиент изпраща POST заявка към `/jobChangeOutfit` като `multipart/form-data`. Заявката трябва да съдържа `userId`, `personImage` (файл) и `garmentImage` (файл).
3.2. **Валидация**: Проверява се дали са предоставени `userId` и двата файла, както и дали Redis и RabbitMQ са налични.
3.3. **Качване на Входни Изображения в R2**:
    - Генерира се уникален `jobId`.
    - Двата файла (`personImage` и `garmentImage`) се качват в Cloudflare R2 под уникални ключове, които включват `jobId` (напр. `jobs/<jobId>/input_person.jpg`).
3.4. **Запис в Redis (Атомарна Операция)**:
    - Използва се Redis `MULTI` транзакция.
    - В Redis Hash с ключ `jobId` се записват данните за задачата, включително:
        - `type: 'outfit_change'`
        - `status: 'pending'`
        - `user_id`
        - `person_image_r2_key` и `garment_image_r2_key` (ключовете към качените файлове в R2).
    - `jobId` се добавя към Redis Set `jobs:status:pending`.
3.5. **Изпращане към RabbitMQ**:
    - Формира се съобщение, съдържащо **само** `jobId`.
    - Съобщението се публикува в специфичния за тази услуга exchange (`OutfitExchange`), който го насочва към опашката `OutfitQueue`.
3.6. **Отговор към Клиента**:
    - Връща се HTTP 201 (Created) отговор, съдържащ `jobId`.
3.7. **Активиране на Диспечера**:
    - Както при другите задачи, диспечерът се активира.
3.8. **Обработка на Грешки**:
    - Ако възникне грешка по време на процеса (напр. при качване в R2 или запис в Redis), се прави опит за почистване чрез `performFullCleanup`, за да се изтрият вече качените файлове от R2.


4. Диспечерски Механизъм (`runDispatcherCycle`)
----------------------------------------------
Тази функция се изпълнява периодично и управлява готовите задачи. Честотата на изпълнение зависи от текущия режим на диспечера:
- **"Работещ" (Active) режим**: По-чести проверки (напр. на всеки 5 секунди). Активира се при създаване на нова задача или при заявка за резултат от задача. Остава активен за определен период след последната активност (напр. 30 секунди).
- **"Заспал" (Idle) режим**: По-редки проверки (напр. на всяка минута). Влиза в този режим, ако няма активност за зададения период.
3.1. **Проверка за Готови Задачи (независимо от режима)**:
    - Извлича всички `jobId`-та от Redis Set `jobs:status:ready`. Този Set се очаква да бъде попълван от worker услугите, след като успешно генерират изображение и го качат в R2.
3.2. **Обработка на Всяка Готова Задача**:
    - За всеки `jobId` от `jobs:status:ready` се извършва следното:
        - Проверява дали задачата вече не е в локалния кеш на диспечера (`readyJobsForClientCache`). Ако е, само се уверява, че е в правилния Redis Set (`JOB_STATUS_DISPATCHER_CACHE_PROCESSING`).
        - Извлича пълните данни за задачата от нейния Redis Hash.
        - **Ако задачата е валидна и готова**:
            - Проверява дали `status` в Hash-а е 'ready' и дали има `output_r2_key` (ключ към генерираното изображение в R2).
            - **Атомарно преместване**: `jobId` се премества от `jobs:status:ready` Set в `jobs:status:dispatcher_cache_processing` Set. Това гарантира, че друга инстанция на диспечера (ако има такива) или същата инстанция при следващ цикъл няма да обработи отново същата задача.
            - **Локално кеширане**: Информацията за задачата (включително `r2Key`, `userId`, време на кеширане и време на изтичане на кеша - TTL) се добавя в локалната `Map` структура `readyJobsForClientCache`.
        - **Обработка на неконсистентност**: Ако задача е в `jobs:status:ready`, но данните в Hash-а не отговарят (напр. различен статус или липсващ `output_r2_key`), тя се премахва от `jobs:status:ready` Set, за да се избегнат проблеми.
3.3. **Почистване на Локалния Кеш (TTL)**:
    - Итерира през задачите в `readyJobsForClientCache`.
    - Ако времето на живот (TTL) на дадена задача в кеша е изтекло (т.е. клиентът не я е потърсил в рамките на зададения период):
        - Задачата се премахва от `readyJobsForClientCache`.
        - Прави се опит `jobId` да бъде преместен обратно от `jobs:status:dispatcher_cache_processing` Set в `jobs:status:ready` Set. Това позволява на задачата да бъде "видяна" отново от диспечера при следващ цикъл или да бъде изтеглена директно от клиента, ако той направи заявка за нея.
        - **Ако преместването е неуспешно**:
            - Проверява се дали задачата все още съществува в Redis.
            - Ако не съществува, това означава, че вероятно е била обработена и изтрита от ендпойнта `/jobResult`. Записът се премахва само от локалния кеш.
            - Ако все още съществува, но преместването е неуспешно по друга причина, записът се премахва от локалния кеш и се логва съобщение.
        - Успешното преместване обратно в `jobs:status:ready` позволява на задачата да бъде "видяна" отново от диспечера при следващ цикъл или да бъде изтеглена директно от клиента.


4. Извличане на Резултат от Задача (`/jobResult?jobId=<ID>`)
-------------------------------------------------------
Клиентите използват този ендпойнт, за да проверяват периодично (polling) дали тяхната задача е готова и да изтеглят резултата.
След успешно получаване на резултата от клиента, всички данни свързани със задачата (в Redis и R2) се изтриват.
4.1. **Получаване на Заявка и Активиране на Диспечера**:
    - Клиент изпраща GET заявка към `/jobResult` с query параметър `jobId`.
    - Тази заявка незабавно превключва диспечерския механизъм в "работещ" режим (или удължава текущия му "работещ" период).
4.2. **Проверка в Локален Кеш (Оптимизация)**:
    - Първо се проверява дали `jobId` съществува в локалния кеш на диспечера (`readyJobsForClientCache`) и дали има валиден `r2Key`.
    - **Ако е намерен в кеша и е готов**:
        - Изображението се извлича от Cloudflare R2.
        - Изпраща се на клиента.
        - Извършва се пълно почистване (`performFullCleanup`).
        - **Не се прави заявка към Redis на този етап.**
4.3. **Извличане на Данни от Redis (ако не е в кеша или кешът е невалиден)**:
    - Сървърът извлича всички данни (Hash) за задачата от Redis чрез `HGETALL jobId`.
4.4. **Обработка на Статуса на Задачата (от Redis)**:
    - **Ако задачата не е намерена в Redis**:
        - Връща се HTTP 404 (Not Found).
    - **Ако задачата е със статус 'ready' и има `output_r2_key`**:
        - Изображението се извлича от Cloudflare R2.
        - Изображението се кодира в Base64 и се изпраща в JSON отговор, съдържащ `status: "completed"`, `image_data_base64` и `image_type`.
        - **Пълно Почистване**: След успешно изпращане на отговора, се извиква функция `performFullCleanup`. Тази функция:
            - Изтрива изображението от Cloudflare R2.
            - Изтрива основния Hash на задачата от Redis.
            - Премахва `jobId` от всички релевантни Redis status Sets (`jobs:status:pending`, `jobs:status:ready`, `jobs:status:dispatcher_cache_processing`).
            - Премахва `jobId` от локалния кеш на диспечера (`readyJobsForClientCache`), ако е там.
        - **При грешка 'NoSuchKey' от R2** (файлът липсва, въпреки че статусът е 'ready'):
            - Връща се HTTP 404.
            - Извиква се `performFullCleanup` (без R2 ключ), за да се почистят данните от Redis.
    - **Ако задачата е със статус 'pending' или 'processing'**: Връща се HTTP 202 (Accepted) със съобщение, че задачата все още се обработва.
    - **Ако задачата е със статус 'failed'**:
        - Връща се HTTP 200 с JSON отговор, съдържащ `status: "failed"` и съобщение за грешка.
        - **Пълно Почистване**: Извиква се `performFullCleanup` (без R2 ключ), за да се изтрият данните за задачата от Redis и локалния кеш на диспечера.
    - **Ако задачата е със статус 'ready', но липсва `output_r2_key` (неконсистентно състояние)**:
        - Връща се HTTP 500.
        - **Пълно Почистване**: Извиква се `performFullCleanup` (без R2 ключ), за да се изтрият данните за задачата от Redis и локалния кеш на диспечера.
    - **Други или неизвестни статуси**:
        - Връща се HTTP 200 с текущия статус на задачата. Данните не се трият на този етап.


5. Предположения за Външни Worker Услуги
5. Предположения за Външни Worker Услуги (Python Worker)
-------------------------------------------------------
Системата разчита на външни Python worker услуги (описани в отделен проект), които са специализирани и изпълняват следните действия:

5.1. **Специализирано Консумиране и Идентификация**:
    - При стартиране, всеки worker се конфигурира интерактивно да слуша **само една** от двете опашки: `TextQueue` (за стандартни задачи) или `OutfitQueue` (за задачи за смяна на облекло). Това позволява разпределение на натоварването и специализация на машините.
    - Worker-ът също така получава уникално име при стартиране (напр. 'Worker-A'), което се използва за логване и проследяване.

5.2. **Управление на Наличността на ComfyUI**:
    - Worker-ът поддържа фонова задача, която периодично проверява наличността на ComfyUI сървъри (чрез Nginx discovery или директна връзка към конфигуриран списък).
    - Ако ComfyUI стане недостъпен, worker-ът временно спира да консумира нови съобщения от RabbitMQ, докато ComfyUI не бъде отново наличен.

5.3. **Обработка на Задачи (Общ Поток)**:
    - **Заключване**: Всяка инстанция на worker-а използва семафор (`processing_lock`), за да гарантира, че само една задача се изпълнява едновременно в даден момент в рамките на тази инстанция. Други задачи ще изчакат асинхронно ключалката да се освободи.
    - **Актуализация на Статус**: Статусът на задачата в Redis се актуализира през целия й жизнен цикъл: `pending` -> `waiting_comfyui` (търси ComfyUI сървър) -> `processing_comfyui` (изпълнява се в ComfyUI).
    - **Намиране на ComfyUI Сървър**: Worker-ът активно търси и избира наличен ComfyUI сървър (чрез Nginx или round-robin от списък), като прави повторни опити при неуспех.
    - **Изпълнение на Workflow**:
        - **За `TextQueue`**: Worker-ът конструира ComfyUI workflow JSON от данните в съобщението и го изпраща.
        - **За `OutfitQueue`**: Worker-ът изтегля входните изображения (`personImage`, `garmentImage`) от Cloudflare R2, качва ги в ComfyUI, конструира специализиран workflow за смяна на облекло и го изпраща.
    - **Изчакване и Извличане на Резултат**: Изчаква завършването на задачата в ComfyUI чрез WebSocket връзка и извлича генерираното изображение.
    - **Качване в Cloudflare R2**: Генерираното изображение се качва в Cloudflare R2.
    - **Финална Актуализация в Redis**:
        - Статусът в Redis се променя на `ready`.
        - Записва се `output_r2_key` (ключа към файла в R2).
        - Добавя се поле `executed_by_comfyui_server`, което съдържа името на worker-а и адреса на ComfyUI сървъра, изпълнил задачата (напр. "Worker-A @ 192.168.0.107:8188").
        - `jobId` се премества в `jobs:status:ready` Set.

5.4. **Обработка на Грешки и Повторни Опити**:
    - Worker-ът има вътрешна логика за локални повторни опити (конфигурируем брой, напр. `settings.TASK_EXECUTION_MAX_RETRIES`).
    - Ако всички опити се провалят, задачата се маркира като `failed` в Redis, записва се съобщение за грешка, и `jobId` се премества в `jobs:status:failed` Set.
    - При неуспех, съобщението от RabbitMQ се `nack`-ва без повторно поставяне (`requeue=False`), за да се избегнат безкрайни цикли.

5.5. **HTTP Ендпойнти (за директна комуникация)**:
    - **`/CreateImageFromPrompt` (POST)**: Позволява директно подаване на задачи за генериране от текст, заобикаляйки RabbitMQ.
        - Данните се валидират, записва се първоначален статус `pending` в Redis и се стартира фонова задача за обработка.
        - HTTP отговорът `{"status": "accepted", "job_id": ...}` се връща **незабавно**.
        - Самата обработка изчаква своя ред, ако `processing_lock` е зает.
        - За разлика от RabbitMQ задачите, ако изпълнението се провали (`execution_failure`), задачата се маркира директно като `failed` в Redis, тъй като няма механизъм за повторен опит на ниво HTTP.
    - **`/status/{job_id}` (GET)**: Връща текущия статус и детайли за дадена задача директно от Redis.

6. Други Ендпойнти
-------------------
6.1. **`/upload` (POST)**:
    - Позволява качване на един или няколко файла (изпратени като `multipart/form-data` с поле `imageFiles` и `userId`).
    - Файловете се записват в Cloudflare R2 под ключ с формат `userId/originalFilename`.
    - Връща информация за качените файлове, включително техните R2 ключове.
6.2. **`/images/:userId` (GET)**:
    - Извлича списък с всички изображения за даден `userId` от R2.
    - Изображенията се връщат като Base64 кодирани низове в JSON масив.
    - **След успешно изпращане на отговора, всички извлечени изображения за този потребител се изтриват от R2.**
6.3. **`/image/raw/:key(*)` (GET)**:
    - Извлича суровите данни на единично изображение от R2 по неговия пълен ключ.
    - Полезен за директна визуализация. **Не изтрива файла.**
6.4. **`/jobs` (POST)**:
    - Подобен на `/jobsRedis`, но записва информацията за задачата в PostgreSQL база данни (`jobs2` таблица).
    - Също изпраща съобщение към RabbitMQ. Този ендпойнт изглежда е по-стара версия или алтернативен начин за управление на задачи, като основният фокус на новата логика е върху Redis.

7. Грациозно Спиране (`gracefulShutdown`)
----------------------------------------
При получаване на сигнал за спиране (SIGINT, SIGTERM):
7.0. Спира се таймерът за активност на диспечера (`activityTimeoutId`), ако е активен.
7.1. Спира се диспечерският интервал (`dispatcherIntervalId`).
7.2. Затварят се връзките към RabbitMQ, Redis и PostgreSQL pool-а, за да се освободят ресурси и да се предотвратят грешки.
7.3. Процесът на приложението приключва.

Този работен процес осигурява асинхронна обработка на задачи, управление на състоянията им чрез Redis и механизъм за клиентите да получават резултатите, когато са готови, като същевременно се управлява натоварването и ресурсите на сървъра.